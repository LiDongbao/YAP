 #ifndef _KERNEL_H_ #define _KERNEL_H_  #include <cusp/complex.h>  const unsigned int TILE_DIM = 32; //16（32） const unsigned int BLOCK_ROWS = 32;//4（8）  __global__ void fftshift(cusp::complex<float> * d_idata, cusp::complex<float> * d_odata) {  	__shared__ cusp::complex<float> tile[TILE_DIM][TILE_DIM + 1]; 	int x = TILE_DIM * blockIdx.x + threadIdx.x; 	int y = TILE_DIM * blockIdx.y + threadIdx.y; 	int width = gridDim.x * TILE_DIM; 	tile[threadIdx.y][threadIdx.x] = d_idata[y*width + x]; 	__syncthreads();  	if (blockIdx.x < width / (TILE_DIM * 2) && blockIdx.y < width / (TILE_DIM * 2)) 	{ 		d_odata[(y + width / 2)*width + x + width / 2] = tile[threadIdx.y][threadIdx.x]; 	} 	if (blockIdx.x < width / (TILE_DIM * 2) && blockIdx.y >= width / (TILE_DIM * 2)) 	{ 		d_odata[(y - width / 2)*width + x + width / 2] = tile[threadIdx.y][threadIdx.x]; 	} 	if (blockIdx.x >= width / (TILE_DIM * 2) && blockIdx.y < width / (TILE_DIM * 2)) 	{ 		d_odata[(y + width / 2)*width + x - width / 2] = tile[threadIdx.y][threadIdx.x]; 	} 	if (blockIdx.x >= width / (TILE_DIM * 2) && blockIdx.y >= width / (TILE_DIM * 2)) 	{ 		d_odata[(y - width / 2)*width + x - width / 2] = tile[threadIdx.y][threadIdx.x]; 	} }     __global__  void ComplexScale(cusp::complex<float>* d_idata, cusp::complex<float>* d_odata, float scale, unsigned int width, unsigned int height) { 	int col = threadIdx.x + blockDim.x * blockIdx.x; 	int row = threadIdx.y + blockIdx.y * blockDim.y; 	if (col< width && row < height) 	{ 		d_odata[row*width + col] = d_idata[row*width + col] * scale; 	} }  #endif //_KERNEL_H_